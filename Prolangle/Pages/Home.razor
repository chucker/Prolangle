@page "/"
@using Prolangle.Languages.Framework
@using Prolangle.Services
@using Prolangle.Components
@using Prolangle.Models
@using Match = Prolangle.Models.Match

@inject GuessGame GuessGame
@inject LanguagesProvider LanguagesProvider

<h1>Guess a Language</h1>

@if (won)
{
	<h2>You won!</h2>
}

<Table>
	<TableHeader>
		<TableRow>
			<TableHeaderCell>Language</TableHeaderCell>
			<TableHeaderCell>Type System</TableHeaderCell>
			<TableHeaderCell>Execution Model</TableHeaderCell>
			<TableHeaderCell>Memory Management</TableHeaderCell>
			<TableHeaderCell>Syntax Style</TableHeaderCell>
			<TableHeaderCell>Known For Building</TableHeaderCell>
			<TableHeaderCell>Paradigms</TableHeaderCell>
			<TableHeaderCell>TIOBE Rating</TableHeaderCell>
			<TableHeaderCell>Appearance Year</TableHeaderCell>
		</TableRow>
	</TableHeader>
	<TableBody>
		@foreach (ILanguage language in RevealedLanguages)
		{
			<TableRow>
				<TableRowHeader>@language.Name</TableRowHeader>
				<TableRowCell>
					<MatchDisplay Match="TypingMatch(language)">
						<LanguageMetadatum Overlap="TypingOverlap(language)" Value="language.Typing" Exclude="TypeSystem.None"/>
					</MatchDisplay>
				</TableRowCell>
				@* <TableRowCell class="@CompiledMatch(language)"> *@
				@* 	@(language.Compiled ? "Compiled" : "Interpreted") *@
				@* </TableRowCell> *@
				@* <TableRowCell class="@GarbageCollectedMatch(language)"> *@
				@* 	<LanguageMemoryManagement MemoryManagement="language.MemoryManagement"/> *@
				@* </TableRowCell> *@
				@* <TableRowCell class="@SyntaxStyleMatch(language)"> *@
				@* 	<LanguageSyntaxStyle SyntaxStyle="language.SyntaxStyle"/> *@
				@* </TableRowCell> *@
				@* <TableRowCell class="@ApplicationsMatch(language) flags"> *@
				@* 	<LanguageMetadatum Overlap="ApplicationsOverlap(language)" Value="language.KnownForBuilding" Exclude="Applications.None"/> *@
				@* </TableRowCell> *@
				@* <TableRowCell class="@ParadigmsMatch(language) flags"> *@
				@* 	<LanguageMetadatum Overlap="ParadigmsOverlap(language)" Value="language.Paradigms" Exclude="Paradigms.None"/> *@
				@* </TableRowCell> *@
				@* <TableRowCell class="@TiobeRatingMatch(language)"> *@
				@* 	@(language.TiobeRating?.ToString() ?? "None") *@
				@* 	@DirectionToString(TiobeRatingDirection(language)) *@
				@* </TableRowCell> *@
				@* <TableRowCell class="@AppearanceYearMatch(language)"> *@
				@* 	@language.AppearanceYear *@
				@* 	@DirectionToString(AppearanceYearDirection(language)) *@
				@* </TableRowCell> *@
			</TableRow>
		}
	</TableBody>
</Table>

<div style="width: 100%; overflow-x: auto">
	<table class="revealed-table table table-bordered">
		<thead>
		<tr>
			<th>Language</th>
			<th>Typing</th>
			<th>Compiled</th>
			<th>Memory Management</th>
			<th>Syntax Style</th>
			<th>Known For Building</th>
			<th>Paradigms</th>
			<th><a href="https://www.tiobe.com/tiobe-index/">TIOBE</a> Rating</th>
			<th>Appearance Year</th>
		</tr>
		</thead>
		<tbody>
		@foreach (ILanguage language in RevealedLanguages)
		{
			<tr class="language-row" @key="language.Id">
				<td>@language.Name</td>
				<td class="@TypingMatch(language) flags">
					<LanguageMetadatum Overlap="TypingOverlap(language)" Value="language.Typing" Exclude="TypeSystem.None"/>
				</td>
				<td class="@CompiledMatch(language)">@(language.Compiled ? "Compiled" : "Interpreted")</td>
				<td class="@GarbageCollectedMatch(language)">
					<LanguageMemoryManagement MemoryManagement="language.MemoryManagement"/>
				</td>
				<td class="@SyntaxStyleMatch(language)">
					<LanguageSyntaxStyle SyntaxStyle="language.SyntaxStyle"/>
				</td>
				<td class="@ApplicationsMatch(language) flags">
					<LanguageMetadatum Overlap="ApplicationsOverlap(language)" Value="language.KnownForBuilding" Exclude="Applications.None"/>
				</td>
				<td class="@ParadigmsMatch(language) flags">
					<LanguageMetadatum Overlap="ParadigmsOverlap(language)" Value="language.Paradigms" Exclude="Paradigms.None"/>
				</td>
				<td class="@TiobeRatingMatch(language)">@(language.TiobeRating?.ToString() ?? "None") @DirectionToString(TiobeRatingDirection(language))</td>
				<td class="@AppearanceYearMatch(language)">@language.AppearanceYear @DirectionToString(AppearanceYearDirection(language))</td>
			</tr>
		}
		</tbody>
	</table>
</div>

@if (!won)
{
	<LanguageSelection AvailableLanguages="@AvailableLanguages" OnLanguageSelected="@OnLanguageSelected"/>
}

@code {
	private List<ILanguage> AvailableLanguages => LanguagesProvider!.Languages.Where(l => !RevealedLanguages.Contains(l)).ToList();
	private List<ILanguage> RevealedLanguages { get; } = [];
	private ILanguage TargetLanguage => LanguagesProvider!.Languages.Single(l => l.Id == GuessGame!.TargetLanguageId);
	private bool won;

	private static string DirectionToString(DirectionIndicator direction)
	{
		return direction switch
		{
			DirectionIndicator.Equal => "",
			DirectionIndicator.Up => "\u25b2",
			DirectionIndicator.Down => "\u25bc",
			_ => throw new ArgumentOutOfRangeException(nameof(direction), direction, null)
		};
	}

	private void OnLanguageSelected(ILanguage language)
	{
		RevealedLanguages.Insert(0, language);

		var result = GuessGame!.TargetLanguageId == language.Id;

		if (result)
			won = true;
	}

	private TypeSystem TypingOverlap(ILanguage language)
	{
		return language.Typing & TargetLanguage.Typing;
	}

	private Applications ApplicationsOverlap(ILanguage language)
	{
		return language.KnownForBuilding & TargetLanguage.KnownForBuilding;
	}

	private Paradigms ParadigmsOverlap(ILanguage language)
	{
		return language.Paradigms & TargetLanguage.Paradigms;
	}

	private DirectionIndicator TiobeRatingDirection(ILanguage language)
	{
		if (language.TiobeRating is null && TargetLanguage.TiobeRating is null)
			return DirectionIndicator.Equal;

		if (language.TiobeRating is null)
			return DirectionIndicator.Up;

		if (TargetLanguage.TiobeRating is null)
			return DirectionIndicator.Down;

		if (language.TiobeRating < TargetLanguage.TiobeRating)
			return DirectionIndicator.Up;

		if (language.TiobeRating > TargetLanguage.TiobeRating)
			return DirectionIndicator.Down;

		return DirectionIndicator.Equal;
	}

	private DirectionIndicator AppearanceYearDirection(ILanguage language)
	{
		if (language.AppearanceYear < TargetLanguage.AppearanceYear)
			return DirectionIndicator.Up;

		if (language.AppearanceYear > TargetLanguage.AppearanceYear)
			return DirectionIndicator.Down;

		return DirectionIndicator.Equal;
	}

	private Match TypingMatch(ILanguage language)
	{
		var overlap = TypingOverlap(language);

		if (overlap == TypeSystem.None)
			return TargetLanguage.Typing == TypeSystem.None ? Match.Exact : Match.None;

		if (TargetLanguage.Typing == language.Typing)
			return Match.Exact;

		return Match.Partial;
	}

	private Match CompiledMatch(ILanguage language)
	{
		if (language.Compiled == TargetLanguage.Compiled)
			return Match.Exact;

		return Match.None;
	}

	private Match GarbageCollectedMatch(ILanguage language)
	{
		if (language.MemoryManagement == TargetLanguage.MemoryManagement)
			return Match.Exact;

		return Match.None;
	}

	private Match SyntaxStyleMatch(ILanguage language)
	{
		if (language.SyntaxStyle == TargetLanguage.SyntaxStyle)
			return Match.Exact;

		return Match.None;
	}

	private Match ApplicationsMatch(ILanguage language)
	{
		var overlap = ApplicationsOverlap(language);

		if (overlap == Applications.None)
			return Match.None;

		if (TargetLanguage.KnownForBuilding == language.KnownForBuilding)
			return Match.Exact;

		return Match.Partial;
	}

	private Match ParadigmsMatch(ILanguage language)
	{
		var overlap = ParadigmsOverlap(language);

		if (overlap == Paradigms.None)
			return Match.None;

		if (TargetLanguage.Paradigms == language.Paradigms)
			return Match.Exact;

		return Match.Partial;
	}

	private Match TiobeRatingMatch(ILanguage language)
	{
		if (language.TiobeRating is null && TargetLanguage.TiobeRating is null)
			return Match.Exact;

		if (language.TiobeRating is null)
			return Match.None;

		if (TargetLanguage.TiobeRating is null)
			return Match.None;

		// floating point comparison
		if (Math.Abs(language.TiobeRating.Value - TargetLanguage.TiobeRating.Value) <= double.Epsilon)
			return Match.Exact;

		return Match.None;
	}

	private Match AppearanceYearMatch(ILanguage language)
	{
		if (language.AppearanceYear == TargetLanguage.AppearanceYear)
			return Match.Exact;

		return Match.None;
	}

}
