@using Microsoft.JSInterop
@using System.Text.Json
@using Prolangle.Services
@using Prolangle.Services.Popover

@implements IAsyncDisposable;

@inject PopoverCoordinator PopoverCoordinator;

@if (WillHavePopover)
{
    <div style="display: none">
        <div @ref="titleElement">
            @if (!string.IsNullOrWhiteSpace(Url))
            {
                <p>@Title</p>
                <p class="m-0 small"><a href="@Url" target="_blank">More Information</a></p>
            }
            else
            {
                <p class="m-0">@Title</p>
            }
        </div>
    </div>

    <span @ref="popoverElement" @onclick="ShowOrReplaceAsync">
        @ChildContent
    </span>
}
else
{
    @ChildContent
}

@code {
    private ElementReference popoverElement;
    private ElementReference titleElement;

    bool WillHavePopover => !string.IsNullOrWhiteSpace(Content);

    [Parameter] public RenderFragment ChildContent { get; set; }

    [Parameter] public string Content { get; set; }
    [Parameter] public string Title { get; set; }
    [Parameter] public string Url { get; set; }

    private async Task ShowOrReplaceAsync()
    {
        await PopoverCoordinator.ShowOrReplaceAsync(popoverElement, GetSerializedOptions());
    }

    // ReSharper disable InconsistentNaming
    record BootstrapPopoverOptions(string content, bool html, string trigger);
    // ReSharper restore InconsistentNaming

    private string GetSerializedOptions()
    {
        // TODO after merging #40: move record to `Prolangle.Services.Popover`

        return JsonSerializer.Serialize(new
        {
            content = Content,
            title = Title,
            trigger = "click",
        });
return JsonSerializer.Serialize(new BootstrapPopoverOptions(Content, true, "click"));

    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        await PopoverCoordinator.RemoveAsync(popoverElement);
    }

}
